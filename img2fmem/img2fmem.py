#!/usr/bin/env python3

# img2fmem.py - image to FPGA memory map converter 2025 edition
# (C)2025 Will Green, open source software released under the MIT License
# For latest version and docs visit https://github.com/projf/fpgatools

"""Image to FPGA memory map converter"""

import os
import sys
from PIL import Image

MESSAGE = "Generated by img2fmem from Project F - https://github.com/projf/fpgatools\n"

if len(sys.argv) not in (4, 5, 6):
    print("Convert image files to FPGA memory maps in $readmemh or Xilinx COE format.")
    print("usage: img2fmem.py image_file colr_bits output_format palette_bits pack")
    print("         image_file: source image file name")
    print("         colr_bits - number of colour index bits per pixel: 1, 4, 6, or 8")
    print("         output_format: mem or coe")
    print("         palette_bits (optional) - number of palette bits: 12, 15, or 24")
    print("         pack (optional) - pixel packing mode: 0, 32")
    print("\nExample: img2fmem.py test.png 4 mem 15 32")
    sys.exit()

# get arguments
input_file = sys.argv[1]
base_name = os.path.splitext(input_file)[0]

colr_bits = int(sys.argv[2])
if colr_bits == 1:
    pal_size = 2
elif colr_bits == 4:
    pal_size = 16
elif colr_bits == 6:
    pal_size = 64
else:  # choose default if palette size if invalid
    colr_bits = 8  # default to 8 bit
    pal_size = 256

output_format = sys.argv[3]

palette_bits = 12  # default to 12 bit output (4 bits per colour) - as in 2018 version
if len(sys.argv) > 4:
    palette_bits = int(sys.argv[4])
    if palette_bits not in (15, 24):  # choose default if depth is invalid
        palette_bits = 12   # 12 bit output (4 bits per colour)

pack_pixels = 0
if len(sys.argv) > 5:
    pack_pixels = int(sys.argv[5])
    if pack_pixels != 32:  # 32-bit only valid packing at present
        pack_pixels = 0   # no packing
pack_num = pack_pixels // colr_bits

# load source image
source_img = Image.open(input_file)
(width, height) = source_img.size  # used for formatting output
if pack_pixels:
    width = width // pack_num

# convert image
if pal_size == 2:  # monochrome with dithering
    dest_img = source_img.convert(mode='1', dither=Image.Dither.FLOYDSTEINBERG)
    dest_pal = [0x00, 0x00, 0x00, 0xFF, 0xFF, 0xFF]
else:  # indexed colour
    dest_img = source_img.quantize(colors=pal_size, method=Image.Quantize.MEDIANCUT)
    dest_pal = dest_img.getpalette()

dest_pixels = dest_img.getdata()

# process and optionally pack pixels
dest_list = []
pack_cnt = 0
packed = 0
for p in dest_pixels:
    if colr_bits == 1 and p != 0:  # convert monochrome white to 1
        p = 1
    if pack_pixels == 0:
        dest_list.append(p)
    else:
        shift = pack_pixels - (pack_cnt + 1) * colr_bits
        packed |= (p << shift)
        if pack_cnt == pack_num - 1:
            dest_list.append(packed)
            pack_cnt = 0
            packed = 0
        else:
            pack_cnt += 1

# memory file header
if output_format == 'mem':
    output_header = "// " + MESSAGE
elif output_format == 'coe':
    output_header = "; " + MESSAGE
    output_header += "memory_initialization_radix=16;\n"  # hex format
    output_header += "memory_initialization_vector=\n"
else:
    print("Error: output_format should be mem or coe.")
    sys.exit()

# generate hex image output
image_output = output_header
width_cnt = 0
for d in dest_list:
    if pack_pixels == 32:
        image_output += f"{d:08X}"
    elif pal_size <= 16:  # only one hex digit needed
        image_output += f"{d:01X}"
    else:  # otherwise two hex digits
        image_output += f"{d:02X}"

    if output_format == 'coe':
        image_output += ","
    if width_cnt == width - 1:
        image_output += "\n"
        width_cnt = 0
    else:
        image_output += " "
        width_cnt = width_cnt + 1

# replace last comma with semicolon to complete coe statement
if output_format == 'coe':
    image_output = image_output[:-2]
    image_output += ";\n"

# write image memory file
with open(base_name + '.' + output_format, 'w', encoding="utf-8") as f:
    f.write(image_output)

# generate hex palette output
palette_output = output_header
if output_format == 'mem':
    for i in range(0, len(dest_pal), 3):
        r, g, b = dest_pal[i], dest_pal[i+1], dest_pal[i+2]
        if palette_bits == 12:
            r = r >> 4
            g = g >> 4
            b = b >> 4
            palette_output += f"{r:01X}{g:01X}{b:01X} "
        elif palette_bits == 15:
            r = r >> 3
            g = g >> 3
            b = b >> 3
            rgb = (r << 10) | (g << 5) | b
            palette_output += f"{rgb:04X} "
        else:  # 24-bit
            palette_output += f"{r:02X}{g:02X}{b:02X} "
    # replace last space with newline
    palette_output = palette_output[:-1]
    palette_output += "\n"
elif output_format == 'coe':
    for i in range(0, len(dest_pal), 3):
        r, g, b = dest_pal[i], dest_pal[i+1], dest_pal[i+2]
        if palette_bits == 12:
            r = r >> 4
            g = g >> 4
            b = b >> 4
            palette_output += f"{r:01X}{g:01X}{b:01X}, "
        elif palette_bits == 15:
            r = r >> 3
            g = g >> 3
            b = b >> 3
            rgb = (r << 10) | (g << 5) | b
            palette_output += f"{rgb:04X}, "
        else:  # 24-bit
            palette_output += f"{r:02X}{g:02X}{b:02X}, "
    # replace last comma with semicolon to complete coe statement
    palette_output = palette_output[:-2]
    palette_output += ";\n"

# write palette memory file
with open(base_name + '_palette.' + output_format, 'w', encoding="utf-8") as f:
    f.write(palette_output)

# save preview image
dest_img.save(base_name + '_preview.png')

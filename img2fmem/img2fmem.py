#!/usr/bin/env python3

# img2fmem.py - image to FPGA memory map converter 2025 edition
# (C)2025 Will Green, open source software released under the MIT License
# For latest version and docs visit https://github.com/projf/fpgatools

"""Image to FPGA memory map converter"""

import os
import sys
from PIL import Image

if len(sys.argv) not in (4, 5, 6):
    print("Convert image files to FPGA memory maps in $readmemh or Xilinx COE format.")
    print("usage: img2fmem.py image_file colour_bits output_format palette_bits pack")
    print("         image_file: source image file name")
    print("         colour_bits - number of colour index bits per pixel: 1, 2, 4, 6, or 8")
    print("         output_format: mem or coe")
    print("         palette_bits (optional) - number of palette bits: 12, 15, or 24")
    print("         pack (optional) - pack pixels into this many bits: none, 16, 32")
    print("\nExample: img2fmem.py test.png 4 mem 15 32")
    sys.exit()

MESSAGE = "Generated by img2fmem.py from Project F - https://github.com/projf/fpgatools\n"

# get arguments
input_file = sys.argv[1]
base_name = os.path.splitext(input_file)[0]

colour_bits = int(sys.argv[2])
if colour_bits == 1:
    pal_size = 2
elif colour_bits == 2:
    pal_size = 4
elif colour_bits == 4:
    pal_size = 16
elif colour_bits == 6:
    pal_size = 64
else:  # choose default if palette size if invalid
    pal_size = 256  # default to 8-bit

output_format = sys.argv[3]

palette_bits = 12  # default to 12 bit output (4 bits per colour) - as in 2018 version
if len(sys.argv) == 5:
    palette_bits = int(sys.argv[4])
    if palette_bits not in (15, 24):  # choose default if depth is invalid
        palette_bits = 12   # 12 bit output (4 bits per colour)

pix_pack = 0
if len(sys.argv) == 6:
    pix_pack = int(sys.argv[5])
    if pix_pack not in (16, 32):  # choose default not 16 or 32-bit
        pix_pack = 0   # no packing
print (f"    DEBUG: pixel packing {pix_pack}")

# load source image
source_img = Image.open(input_file)
(width, height) = source_img.size  # used for formatting output

# convert image
if pal_size == 2:  # monochrome with dithering
    dest_img = source_img.convert(mode='1', dither=Image.Dither.FLOYDSTEINBERG)
    dest_pal = [0x00, 0x00, 0x00, 0xFF, 0xFF, 0xFF]
else:  # indexed colour
    dest_img = source_img.quantize(colors=pal_size, method=Image.Quantize.MEDIANCUT)
    dest_pal = dest_img.getpalette()

# generate hex image output
image_data = dest_img.getdata()
image_output = ''
width_cnt = 0
if output_format == 'mem':
    image_output += "// " + MESSAGE
    for d in image_data:
        if pal_size == 2:
            if d == 0:
                image_output += "1"
            else:
                image_output += "0"
        elif pal_size <= 16:  # only one hex digit needed
            image_output += f"{d:01X}"
        else:
            image_output += f"{d:02X}"
        if width_cnt == width - 1:
            image_output += "\n"
            width_cnt = 0
        else:
            image_output += " "
            width_cnt = width_cnt + 1
elif output_format == 'coe':
    image_output += "; " + MESSAGE
    image_output += "memory_initialization_radix=16;\n"  # hex format
    image_output += "memory_initialization_vector=\n"
    for d in image_data:
        if pal_size == 2:
            if d == 0:
                image_output += "1,"
            else:
                image_output += "0,"
        elif pal_size <= 16:
            image_output += f"{d:01X},"
        else:
            image_output += f"{d:02X},"
        if width_cnt == width - 1:
            image_output += "\n"
            width_cnt = 0
        else:
            image_output += " "
            width_cnt = width_cnt + 1
    # replace last comma with semicolon to complete coe statement
    image_output = image_output[:-2]
    image_output += ";\n"
else:
    print("Error: output_format should be mem or coe.")
    sys.exit()

with open(base_name + '.' + output_format, 'w', encoding="utf-8") as f:
    f.write(image_output)

# generate hex palette output
palette_output = ''
if output_format == 'mem':
    palette_output += "// " + MESSAGE
    for i in range(0, len(dest_pal), 3):
        r, g, b = dest_pal[i], dest_pal[i+1], dest_pal[i+2]
        if palette_bits == 12:
            r = r >> 4
            g = g >> 4
            b = b >> 4
            palette_output += f"{r:01X}{g:01X}{b:01X} "
        elif palette_bits == 15:
            r = r >> 3
            g = g >> 3
            b = b >> 3
            rgb = (r << 10) | (g << 5) | b
            palette_output += f"{rgb:04X} "
        else:  # 24-bit
            palette_output += f"{r:02X}{g:02X}{b:02X} "
    # replace last space with newline
    palette_output = palette_output[:-1]
    palette_output += "\n"
elif output_format == 'coe':
    palette_output += "; " + MESSAGE
    palette_output += "memory_initialization_radix=16;\n"
    palette_output += "memory_initialization_vector="
    for i in range(0, len(dest_pal), 3):
        r, g, b = dest_pal[i], dest_pal[i+1], dest_pal[i+2]
        if palette_bits == 12:
            r = r >> 4
            g = g >> 4
            b = b >> 4
            palette_output += f"{r:01X}{g:01X}{b:01X}, "
        elif palette_bits == 15:
            r = r >> 3
            g = g >> 3
            b = b >> 3
            rgb = (r << 10) | (g << 5) | b
            palette_output += f"{rgb:04X}, "
        else:  # 24-bit
            palette_output += f"{r:02X}{g:02X}{b:02X}, "
    # replace last comma with semicolon to complete coe statement
    palette_output = palette_output[:-2]
    palette_output += ";\n"
else:
    print("Error: output_format should be mem or coe.")
    sys.exit()

with open(base_name + '_palette.' + output_format, 'w', encoding="utf-8") as f:
    f.write(palette_output)

# save preview image and save
dest_img.save(base_name + '_preview.png')
